<!DOCTYPE html>
<!-- HTML 문서의 루트 요소를 시작합니다. 모든 콘텐츠는 이 안에 들어갑니다. -->
<html>
  <!-- 문서 정보를 담는 머리글(head) 영역입니다. 화면에 직접 보이지 않는 설정들을 넣습니다. -->
  <head>
    <!-- 문서에서 한글 등 다양한 문자를 올바르게 표시하도록 문자 인코딩을 UTF-8로 지정합니다. -->
    <meta charset="UTF-8" />
    <!-- 인터넷 익스플로러 호환 모드 설정입니다. 최신 렌더링 엔진을 사용하도록 지시합니다. -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- 반응형 웹을 위한 뷰포트 설정입니다. 모바일/태블릿에서 화면 크기에 맞게 보이도록 합니다. -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
    />
    <!-- 외부 CSS 파일을 연결합니다. 페이지의 스타일(색, 배치 등)을 정의합니다. -->
    <link rel="stylesheet" href="./naver_map_style.css" />
    <!-- 브라우저 탭에 표시될 문서의 제목(title)입니다. -->
    <title>네이버 지도 표시하기</title>
  </head>
  <!-- 실제 화면에 보이는 본문(body) 영역입니다. 우리가 볼 내용들이 여기에 들어갑니다. -->
  <body>
    <!-- 지도를 포함한 전체 레이아웃을 감싸는 컨테이너입니다. CSS로 배치를 제어합니다. -->
    <div class="map-layout">
      <!-- 왼쪽에 표시되는 범례 영역(legend)입니다. 표시되는 마커 종류를 안내합니다. -->
      <aside class="legend">
        <!-- 범례 제목입니다. 굵게(b 볼더체)로 강조했습니다. -->
        <div class="legend-title"><b>마커 종류</b></div>
        <!-- 범례 항목을 담을 목록입니다. 자바스크립트로 동적으로 채워집니다. -->
        <ul id="legendList" class="legend-list"></ul>
      </aside>

      <!-- 지도와 상단 제어 UI를 담는 오른쪽 패널입니다. -->
      <section class="map-panel">
        <!-- 마커 타입 선택 UI: 사용자가 어떤 장치(마커)를 추가할지 선택합니다. -->
        <div class="device-type-select">
          <!-- label은 입력 요소와 연결되어 의미를 설명합니다. for는 연결할 요소의 id를 가리킵니다. -->
          <label for="deviceType"><b>장치 타입 선택:</b></label>
          <!-- 드롭다운 목록입니다. 여기서 선택한 값이 지도에 추가될 마커의 종류가 됩니다. -->
          <select id="deviceType">
            <!-- 각 option은 선택 가능한 하나의 항목입니다. 괄호 안은 마커의 모양 설명입니다. -->
            <option value="악취측정기">악취측정기(원)</option>
            <option value="음수투약기">음수투약기(사각형)</option>
            <option value="풍향풍속계">풍향풍속계(삼각형)</option>
            <option value="게이트웨이">게이트웨이(마름모)</option>
          </select>
          <!-- 현재 지도에 추가된 마커의 개수를 요약해서 보여주는 영역입니다. -->
          <div id="markerCountInfo" style="margin-top: 8px; font-size: 12px; color: #666;">
            전체: 0/40 | 악취측정기: 0/15 | 음수투약기: 0/8 | 풍향풍속계: 0/10 | 게이트웨이: 0/7
          </div>
        </div>
        <!-- 실제 네이버 지도가 표시될 영역입니다. 자바스크립트에서 이 id를 사용해 지도를 생성합니다. -->
        <div id="map"></div>
      </section>
    </div>


    <!-- 자바스크립트 실행 영역임. type="module"은 모듈 시스템 사용 의미임. -->
    <!-- 왜 자바스크립트? 브라우저가 기본으로 이해하고 즉시 실행함. 추가 설치/컴파일 필요 없음. -->
    <!-- 자바랑 다름. 이름만 비슷함. 자바는 보통 컴파일해서 서버/앱에서 돌림. JS는 브라우저가 바로 돌림. -->
    <!-- 왜 모듈? 파일 나눠 import/export 가능해짐. 전역 변수 충돌 방지됨. 코드 구조 명확해짐. -->
    <script type="module">
      // 참고: 자바 아님. 자바스크립트임.
      // 이유: 브라우저가 곧바로 이해하고 실행함. 추가 설치/컴파일 불필요함.
      // type="module" 이유: import 사용 가능. 파일별 스코프 분리로 안전성↑.
      // 외부 설정 값을 불러옵니다(예: API 키, 기본 설정 등).
      import CONFIG from './config.js';

      // 네이버 지도 객체를 담을 변수를 준비합니다.
      let map = null;
      // 마커 추가/삭제, 연결선 관리 등 지도 위 장치들을 통합 관리하는 매니저입니다.
      let mapDeviceManager = null;
      // 악취가 확산되는 반경(미터). 시각화에 사용됩니다.
      const DEFAULT_ODOR_RADIUS_M = 120; // 악취 확산 반경(미터)
      

      // 클래스 정의 (onload 바깥)
      // 지도 위 장치(마커)들을 생성/관리하는 클래스입니다.
      class MapDeviceManager {
        // 클래스를 사용할 때 자동으로 호출되는 생성자입니다. 전달받은 지도 객체를 저장합니다.
        constructor(map) {
          this.map = map;
          // 현재 지도에 올려진 모든 마커 정보를 보관합니다.
          this.markers = [];
          // 마커에 고유 번호를 붙이기 위한 시퀀스입니다.
          this.markerIdSeq = 1;
          // 게이트웨이와 다른 장치를 선으로 연결할 때 생성되는 선(Polyline)들을 보관합니다.
          this.connectionLines = [];
          // 악취 확산을 표현하는 오버레이(시각화 레이어)입니다. 필요시 주입합니다.
          this.odorOverlay = null; // 악취 확산 오버레이 (로드 후 주입)
          
          // 마커 개수 제한 설정
          // 전체 최대 마커 개수 제한입니다. 너무 많이 추가되는 것을 방지합니다.
          this.maxMarkers = 40; // 전체 최대 마커 개수
          // 장치 종류별(타입별) 최대 허용 개수입니다.
          this.maxMarkersPerType = {
            '악취측정기': 15,
            '음수투약기': 8,
            '풍향풍속계': 10,
            '게이트웨이': 7
          };
        }

        // 마커를 추가해도 되는지(전체/타입별 개수 제한 확인) 검사합니다.
        canAddMarker(type) {
          // 전체 마커 개수 확인
          if (this.markers.length >= this.maxMarkers) {
            alert(`최대 ${this.maxMarkers}개의 마커만 추가할 수 있습니다.`);
            return false;
          }
          
          // 타입별 마커 개수 확인
          const currentTypeCount = this.markers.filter(m => m.type === type).length;
          const maxTypeCount = this.maxMarkersPerType[type];
          
          if (currentTypeCount >= maxTypeCount) {
            alert(`${type}은(는) 최대 ${maxTypeCount}개만 추가할 수 있습니다.`);
            return false;
          }
          
          return true;
        }

        // 지도를 클릭했을 때 선택된 타입으로 실제 마커를 생성하고 부가 요소를 붙입니다.
        addDeviceMarker(device) {
          // 마커 추가 가능 여부 확인
          if (!this.canAddMarker(device.type)) {
            return;
          }
          
          // 장치 타입에 맞는 아이콘(원/삼각형/사각형/마름모)을 그림으로 생성합니다.
          const icon = this.createDeviceIcon(device.type);
          // 네이버 지도에 표시되는 실제 마커를 만듭니다.
          const marker = new naver.maps.Marker({
            position: new naver.maps.LatLng(device.lat, device.lng),
            map: this.map,
            icon: icon,
            draggable: true,
            zIndex: 10
          });

          // 마커 위 삭제 버튼
          // 마커 위에 떠 있는 삭제 버튼(InfoWindow)을 만듭니다.
          const deleteLabel = new naver.maps.InfoWindow({
            content: `
              <div class="marker-name-label">
                <button class="delete-btn" onclick="window.deleteMarker(${device.id})">삭제</button>
              </div>
            `,
            borderWidth: 0,
            backgroundColor: 'transparent',
            anchorSize: new naver.maps.Size(0, 0),
            anchorColor: 'transparent',
            pixelOffset: new naver.maps.Point(0, -50)
          });
          deleteLabel.open(this.map, marker);

          // 마커 아래 라벨 (장치 종류) - 항상 표시 (OverlayView 사용)
          // 마커 아래에 항상 보이는 텍스트 라벨을 위한 사용자 정의 오버레이입니다.
          class TypeLabelOverlay extends naver.maps.OverlayView {
            constructor(position, content) {
              super();
              this.position = position;
              this.content = content;
              this.setMap(map);
            }
            
            onAdd() {
              const div = document.createElement('div');
              div.className = 'marker-type-label';
              div.innerHTML = this.content;
              div.style.position = 'absolute';
              div.style.zIndex = '15';
              div.style.pointerEvents = 'none';
              this.div = div;
              this.getPanes().overlayLayer.appendChild(div);
              this.draw();
            }
            
            onRemove() {
              if (this.div && this.div.parentNode) {
                this.div.parentNode.removeChild(this.div);
              }
              this.div = null;
            }
            
            draw() {
              if (!this.div) return;
              
              const projection = this.getProjection();
              const point = projection.fromCoordToOffset(this.position);
              
              // 현재 지도 상태 정보
              const currentMapState = {
                lat: this.position.lat(),
                lng: this.position.lng(),
                zoom: this.getMap().getZoom(),
                size: this.getMap().getSize().toString() // 지도 크기 변화 감지
              };
              
              // 지도 상태가 변경되었는지 확인 (위도/경도 + 줌 + 크기)
              if (this.cachedMapState && 
                  this.cachedMapState.lat === currentMapState.lat &&
                  this.cachedMapState.lng === currentMapState.lng &&
                  this.cachedMapState.zoom === currentMapState.zoom &&
                  this.cachedMapState.size === currentMapState.size) {
                return; // 모든 상태가 같으면 업데이트 생략
              }
              
              // 캐시 업데이트
              this.cachedMapState = currentMapState;
              
              // transform을 사용하여 더 빠른 위치 업데이트
              this.div.style.transform = `translate(${point.x - this.div.offsetWidth / 2}px, ${point.y + 20}px)`;
            }
            
            setPosition(position) {
              // 위치가 실제로 변경되었는지 확인
              if (this.position && 
                  this.position.lat() === position.lat() && 
                  this.position.lng() === position.lng()) {
                return; // 위치가 같으면 업데이트 안함
              }
              
              this.position = position;
              this.draw();
            }
          }
          
          // 생성한 라벨 오버레이를 마커 위치에 붙입니다.
          const typeLabel = new TypeLabelOverlay(
            new naver.maps.LatLng(device.lat, device.lng),
            device.type
          );

          // 센서별 측정 데이터 정보 생성
          // 장치(센서) 종류에 따라 측정/기능 정보를 문자열로 반환합니다.
          const getSensorDataInfo = (type) => {
            switch(type) {
              case '악취측정기':
                return `
                  <b>측정 데이터:</b><br>
                  • Gas 1~4 [ppm]: 암모니아, 황화수소, 이산화탄소, 메탄<br>
                  • 온도<br>
                  • 습도
                `;
              case '음수투약기':
                return `
                  <b>측정 데이터:</b><br>
                  • 순시투입량<br>
                  • 누적투입량
                `;
              case '풍향풍속계':
                return `
                  <b>측정 데이터:</b><br>
                  • 풍향<br>
                  • 풍속
                `;
              case '게이트웨이':
                return `
                  <b>기능:</b><br>
                  • 데이터 수집 및 전송
                `;
              default:
                return '';
            }
          };

          // 상세 정보 InfoWindow
          // 마커를 클릭하면 보이는 상세 정보창입니다.
          const detailInfo = new naver.maps.InfoWindow({
            content: `
              <div class="device-detail-info">
                <b>${device.type}</b><br>
                위도: <span style="color:#1976d2;">${device.lat.toFixed(6)}</span><br>
                경도: <span style="color:#1976d2;">${device.lng.toFixed(6)}</span><br>
                ${getSensorDataInfo(device.type)}
                <button class="detail-delete-btn" onclick="window.deleteMarker(${device.id})">삭제</button>
              </div>
            `,
            borderWidth: 0,
            backgroundColor: 'transparent',
            anchorSize: new naver.maps.Size(0, 0),
            anchorColor: 'transparent',
            pixelOffset: new naver.maps.Point(0, -80)
          });

          // 마커 클릭 시 상세 정보 토글
          // 상세 정보창이 열려있는지 상태를 기억합니다.
          let detailOpen = false;
          // 마커를 클릭하면 상세 정보를 열고, 다시 클릭하면 닫습니다.
          marker.addListener('click', () => {
            if (!detailOpen) {
              detailInfo.open(this.map, marker);
              detailOpen = true;
            } else {
              detailInfo.close();
              detailOpen = false;
            }
          });

          // 마커 드래그 시 라벨/연결선 동기화 (최적화 + 캐싱)
          // 드래그 중 불필요한 연산을 줄이기 위해 마지막 위치를 저장합니다.
          let lastDragPosition = null;
          // 마커를 드래그하는 동안 라벨과 삭제 버튼의 위치를 따라가게 업데이트합니다.
          marker.addListener('drag', (e) => {
            requestAnimationFrame(() => {
              const newPosition = marker.getPosition();
              
              // 위치가 실제로 변경되었는지 확인
              if (lastDragPosition && 
                  lastDragPosition.lat() === newPosition.lat() && 
                  lastDragPosition.lng() === newPosition.lng()) {
                return; // 위치가 같으면 업데이트 안함
              }
              
              lastDragPosition = newPosition;
              device.lat = newPosition.lat();
              device.lng = newPosition.lng();
              
              // 라벨 위치 업데이트 (즉시)
              deleteLabel.setPosition(newPosition);
              typeLabel.setPosition(new naver.maps.LatLng(device.lat, device.lng));
            });
          });

          // 마커 드래그가 끝난 후 무거운 작업들 처리
          // 드래그가 끝나면 연결선/악취 오버레이를 다시 계산하고, 상세 정보 내용을 갱신합니다.
          marker.addListener('dragend', () => {
            // InfoWindow 내용 업데이트
            detailInfo.setContent(`
              <div class="device-detail-info">
                <b>${device.type}</b><br>
                위도: <span style="color:#1976d2;">${device.lat.toFixed(6)}</span><br>
                경도: <span style="color:#1976d2;">${device.lng.toFixed(6)}</span><br>
                ${getSensorDataInfo(device.type)}
                <button class="detail-delete-btn" onclick="window.deleteMarker(${device.id})">삭제</button>
              </div>
            `);
            
            // 연결선과 악취 확산 업데이트
            this.updateConnections();
            this.updateOdorOverlay();
          });

          // 전역 삭제 함수 등록
          // 전역 함수로 삭제 기능을 노출합니다(버튼에서 호출합니다).
          window.deleteMarker = (id) => {
            const targetMarker = this.markers.find(m => m.id === id);
            if (targetMarker) {
              targetMarker.marker.setMap(null);
              targetMarker.deleteLabel.close();
              targetMarker.typeLabel.setMap(null);
              targetMarker.detailInfo.close();
              this.markers = this.markers.filter(m => m.id !== id);
              this.updateConnections();
              this.updateOdorOverlay();
              this.updateMarkerCountInfo();
            }
          };

          this.markers.push({ 
            ...device, 
            marker, 
            deleteLabel, 
            typeLabel, 
            detailInfo 
          });
          // 게이트웨이-장치 간 연결선, 악취 오버레이, 개수 정보를 최신 상태로 만듭니다.
          this.updateConnections();
          this.updateOdorOverlay();
          this.updateMarkerCountInfo();
        }

        // 마커 개수 정보 업데이트
        // 화면 우측 상단 정보 영역에 현재 마커 개수를 반영합니다.
        updateMarkerCountInfo() {
          const countInfo = document.getElementById('markerCountInfo');
          if (!countInfo) return;
          
          const totalCount = this.markers.length;
          const odorCount = this.markers.filter(m => m.type === '악취측정기').length;
          const waterCount = this.markers.filter(m => m.type === '음수투약기').length;
          const windCount = this.markers.filter(m => m.type === '풍향풍속계').length;
          const gatewayCount = this.markers.filter(m => m.type === '게이트웨이').length;
          
          countInfo.innerHTML = `
            전체: ${totalCount}/${this.maxMarkers} | 
            악취측정기: ${odorCount}/${this.maxMarkersPerType['악취측정기']} | 
            음수투약기: ${waterCount}/${this.maxMarkersPerType['음수투약기']} | 
            풍향풍속계: ${windCount}/${this.maxMarkersPerType['풍향풍속계']} | 
            게이트웨이: ${gatewayCount}/${this.maxMarkersPerType['게이트웨이']}
          `;
          
          // 제한에 가까워지면 색상 변경
          if (totalCount >= this.maxMarkers * 0.8) {
            countInfo.style.color = '#e53935';
          } else if (totalCount >= this.maxMarkers * 0.6) {
            countInfo.style.color = '#f57c00';
          } else {
            countInfo.style.color = '#666';
          }
        }

        // 게이트웨이와 다른 모든 장치를 선으로 연결해 보여줍니다.
        updateConnections() {
          // 기존 연결선 제거
          this.connectionLines.forEach(line => line.setMap(null));
          this.connectionLines = [];
          // 게이트웨이와 다른 노드 연결
          const gateways = this.markers.filter(m => m.type === '게이트웨이');
          const others = this.markers.filter(m => m.type !== '게이트웨이');
          
          console.log('연결선 업데이트:', { gateways: gateways.length, others: others.length });
          
          gateways.forEach(gateway => {
            others.forEach(other => {
              // 마커의 현재 위치를 가져와서 연결선 생성
              const gatewayPos = gateway.marker.getPosition();
              const otherPos = other.marker.getPosition();
              const line = new naver.maps.Polyline({
                path: [
                  new naver.maps.LatLng(gatewayPos.lat(), gatewayPos.lng()),
                  new naver.maps.LatLng(otherPos.lat(), otherPos.lng())
                ],
                strokeColor: '#e53935',
                strokeWeight: 3,
                strokeOpacity: 0.8,
                strokeStyle: 'dashed',
                map: this.map,
                zIndex: 5
              });
              this.connectionLines.push(line);
              console.log('연결선 생성:', gateway.type, '->', other.type);
            });
          });
        }

        // 장치 타입에 따라 다른 모양/색상의 마커 아이콘을 그립니다.
        createDeviceIcon(type) {
          const size = 36;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          ctx.lineWidth = 2;
          let fill = '#1976d2';
          let stroke = '#1565c0';
          
          // 타입별 색상 설정
          if (type === '게이트웨이') {
            fill = '#43a047';
            stroke = '#2e7d32';
          } else if (type === '음수투약기') {
            fill = '#ff9800';
            stroke = '#f57c00';
          } else if (type === '풍향풍속계') {
            fill = '#9c27b0';
            stroke = '#7b1fa2';
          } else if (type === '악취측정기') {
            fill = '#2196f3';
            stroke = '#1976d2';
          }
          
          ctx.strokeStyle = stroke;
          ctx.fillStyle = fill;
          
          if (type === '악취측정기') {
            // 원형 아이콘 (기존 악취측정기와 동일)
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 2 - 3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
          } else if (type === '풍향풍속계') {
            // 삼각형 아이콘 (기존 풍향계와 동일)
            ctx.beginPath();
            ctx.moveTo(size / 2, 4);
            ctx.lineTo(size - 4, size - 4);
            ctx.lineTo(4, size - 4);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          } else if (type === '음수투약기') {
            // 사각형 아이콘 (기존 악취저감장치와 동일)
            ctx.fillRect(4, 4, size - 8, size - 8);
            ctx.strokeRect(4, 4, size - 8, size - 8);
          } else if (type === '게이트웨이') {
            // 마름모 아이콘 (기존과 동일)
            ctx.beginPath();
            ctx.moveTo(size / 2, 4);
            ctx.lineTo(size - 4, size / 2);
            ctx.lineTo(size / 2, size - 4);
            ctx.lineTo(4, size / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }
          return {
            url: canvas.toDataURL(),
            size: new naver.maps.Size(size, size),
            origin: new naver.maps.Point(0, 0),
            anchor: new naver.maps.Point(size / 2, size / 2)
          };
        }

        // 외부에서 악취 확산 오버레이를 주입하는 메서드입니다.
        setOdorOverlay(overlay) {
          this.odorOverlay = overlay;
          this.updateOdorOverlay();
        }

        // 현재 '악취측정기' 마커들의 위치를 기반으로 악취 확산 오버레이를 갱신합니다.
        updateOdorOverlay() {
          if (!this.odorOverlay) return;
          const sensors = this.markers
            .filter(m => m.type === '악취측정기')
            .map(m => {
              const pos = m.marker.getPosition();
              return { lat: pos.lat(), lng: pos.lng() };
            });
          console.log('악취 확산 업데이트:', sensors.length, '개 센서');
          this.odorOverlay.setSensors(sensors);
        }


      }

      // 지도 클릭 이벤트 등록 함수 (onload 바깥)
      // 지도를 클릭했을 때 선택된 장치 타입의 마커를 추가하는 이벤트를 등록합니다.
      function setupMapEvents() {
        if (!map || !mapDeviceManager) return;
        map.addListener('click', function(e) {
          const type = document.getElementById('deviceType').value;
          const name = type + ' ' + mapDeviceManager.markerIdSeq;
          mapDeviceManager.addDeviceMarker({
            id: mapDeviceManager.markerIdSeq++,
            type,
            name,
            lat: e.coord.lat(),
            lng: e.coord.lng()
          });
        });
      }

      // 좌측 범례 생성 (지도/매니저 생성 이후 호출)
      // 좌측 범례(아이콘 + 텍스트)를 동적으로 그리는 함수입니다.
      function renderLegend() {
        const legendList = document.getElementById('legendList');
        if (!legendList || !mapDeviceManager) return;
        const items = [
          { type: '악취측정기', label: '악취측정기' },
          { type: '음수투약기', label: '음수투약기' },
          { type: '풍향풍속계', label: '풍향풍속계' },
          { type: '게이트웨이', label: '게이트웨이' }
        ];
        legendList.innerHTML = '';
        items.forEach((item) => {
          const icon = mapDeviceManager.createDeviceIcon(item.type);
          const li = document.createElement('li');
          li.className = 'legend-item';
          const img = document.createElement('img');
          img.className = 'legend-icon';
          img.src = icon.url;
          img.alt = item.label;
          const span = document.createElement('span');
          span.className = 'legend-label';
          span.textContent = item.label;
          li.appendChild(img);
          li.appendChild(span);
          legendList.appendChild(li);
        });
      }

      // 네이버 지도 API 로드 후 map만 생성, 나머지는 바깥에서 관리
      // 네이버 지도 SDK 스크립트를 동적으로 생성해 문서에 삽입함.
      // 이유: SDK 로드가 끝난 '이후'에만 지도를 초기화하려고 onload 사용함.
      // 선 초기화 시 문제: SDK 미로딩 상태면 naver.maps 없음 → 에러 남.
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = `https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=tygsu6tj2w`;
      document.head.appendChild(script);

      // SDK 로드 완료 시 실행되는 초기화 코드임.
      // 이유: 로드 완료 후에야 naver.maps 객체 생김. 그때 지도 생성 가능함.
      script.onload = () => {
        
        // OdorHeatmapOverlay 정의 (SDK 로드 이후 안전하게 정의)
        /*
        class OdorHeatmapOverlay extends naver.maps.OverlayView {
          constructor(map, radiusMeters = DEFAULT_ODOR_RADIUS_M) {
            super();
            this.map = map;
            this.radiusMeters = radiusMeters;
            this.sensors = [];
            this.canvas = null;
            this.pixelRatio = Math.max(1, window.devicePixelRatio || 1);
            this.setMap(map);
          }
          onAdd() {
            const canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.left = '0px';
            canvas.style.top = '0px';
            canvas.style.pointerEvents = 'none';
            this.canvas = canvas;
            this.getPanes().overlayLayer.appendChild(canvas);
          }
          onRemove() {
            if (this.canvas && this.canvas.parentNode) {
              this.canvas.parentNode.removeChild(this.canvas);
            }
            this.canvas = null;
          }
          setSensors(sensors) {
            this.sensors = sensors || [];
            this.draw();
          }
          setRadiusMeters(radiusMeters) {
            this.radiusMeters = radiusMeters;
            this.draw();
          }
          metersToPixels(meters, latitudeDegrees) {
            const radians = Math.PI / 180;
            const metersPerDegreeLng = 111320 * Math.cos(latitudeDegrees * radians);
            const deltaLng = meters / metersPerDegreeLng;
            const proj = this.getProjection();
            const p1 = proj.fromCoordToOffset(new naver.maps.LatLng(latitudeDegrees, 0));
            const p2 = proj.fromCoordToOffset(new naver.maps.LatLng(latitudeDegrees, deltaLng));
            return Math.abs((p2.x - p1.x));
          }
          colorRamp(t) {
            const stops = [
              { c: [33,150,243] },
              { c: [67,160,71] },
              { c: [253,216,53] },
              { c: [251,140,0] },
              { c: [229,57,53] }
            ];
            const n = stops.length - 1;
            const scaled = Math.min(n, Math.max(0, t * n));
            const i = Math.floor(scaled);
            const f = scaled - i;
            const c0 = stops[i].c, c1 = stops[Math.min(n, i + 1)].c;
            const r = Math.round(c0[0] + (c1[0] - c0[0]) * f);
            const g = Math.round(c0[1] + (c1[1] - c0[1]) * f);
            const b = Math.round(c0[2] + (c1[2] - c0[2]) * f);
            const a = Math.min(0.6, 0.15 + 0.45 * t);
            return [r, g, b, Math.round(a * 255)];
          }
          draw() {
            if (!this.canvas) return;
            const mapSize = this.getMap().getSize();
            const width = mapSize.width;
            const height = mapSize.height;
            const ratio = this.pixelRatio;
            if (this.canvas.width !== width * ratio || this.canvas.height !== height * ratio) {
              this.canvas.width = width * ratio;
              this.canvas.height = height * ratio;
              this.canvas.style.width = width + 'px';
              this.canvas.style.height = height + 'px';
            }
            const ctx = this.canvas.getContext('2d');
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (!this.sensors || this.sensors.length === 0) return;
            const intensityCanvas = document.createElement('canvas');
            intensityCanvas.width = this.canvas.width;
            intensityCanvas.height = this.canvas.height;
            const ictx = intensityCanvas.getContext('2d');
            ictx.clearRect(0, 0, intensityCanvas.width, intensityCanvas.height);
            // 알파 누적 방식으로 겹침 강도 표현
            ictx.globalCompositeOperation = 'source-over';
            const proj = this.getProjection();
            for (const s of this.sensors) {
              const coord = new naver.maps.LatLng(s.lat, s.lng);
              const p = proj.fromCoordToOffset(coord);
              const cx = p.x * ratio;
              const cy = p.y * ratio;
              const radiusPx = this.metersToPixels(DEFAULT_ODOR_RADIUS_M, s.lat) * ratio;
              const grad = ictx.createRadialGradient(cx, cy, 0, cx, cy, radiusPx);
              // 단일 원은 낮은 강도(파랑으로 매핑). 겹칠수록 누적되어 단계 상승
              grad.addColorStop(0, 'rgba(0,0,0,0.22)');
              grad.addColorStop(1, 'rgba(0,0,0,0)');
              ictx.fillStyle = grad;
              ictx.beginPath();
              ictx.arc(cx, cy, radiusPx, 0, Math.PI * 2);
              ictx.fill();
            }
            const img = ictx.getImageData(0, 0, intensityCanvas.width, intensityCanvas.height);
            const data = img.data;
            for (let i = 0; i < data.length; i += 4) {
              const aVal = data[i + 3];
              if (aVal < 6) { data[i + 3] = 0; continue; }
              const t = aVal / 255;
              const [r, g, b, a] = this.colorRamp(t);
              data[i] = r; data[i + 1] = g; data[i + 2] = b; data[i + 3] = a;
            }
            ctx.putImageData(img, 0, 0);
          }
        }*/
        // 확대/축소에 따라 크기가 변하는 이미지 지상 오버레이
        // 지도 위 특정 영역에 이미지를 깔아(지상 오버레이) 확대/축소에 맞춰 크기를 변화시키는 클래스입니다.
        class GroundImageOverlay extends naver.maps.OverlayView {
          constructor(map, imageUrl, bounds, opacity = 0.5) {
            super();
            this.map = map;
            this.imageUrl = imageUrl;
            this.bounds = bounds;
            this.opacity = opacity;
            this.img = null;
            this.setMap(map);
          }
          onAdd() {
            const img = document.createElement('img');
            img.src = this.imageUrl;
            img.style.position = 'absolute';
            img.style.pointerEvents = 'none';
            img.style.opacity = String(this.opacity);
            img.style.transformOrigin = 'top left';
            this.img = img;
            this.getPanes().overlayLayer.appendChild(img);
          }
          onRemove() {
            if (this.img && this.img.parentNode) {
              this.img.parentNode.removeChild(this.img);
            }
            this.img = null;
          }
          setOpacity(opacity) {
            this.opacity = opacity;
            if (this.img) this.img.style.opacity = String(opacity);
          }
          setUrl(url) {
            this.imageUrl = url;
            if (this.img) this.img.src = url;
          }
          setBounds(bounds) {
            this.bounds = bounds;
            this.draw();
          }
          draw() {
            if (!this.img || !this.bounds) return;
            const proj = this.getProjection();
            const sw = proj.fromCoordToOffset(this.bounds.getSW());
            const ne = proj.fromCoordToOffset(this.bounds.getNE());
            const left = sw.x;
            const top = ne.y;
            const width = ne.x - sw.x;
            const height = sw.y - ne.y;
            if (width <= 0 || height <= 0) return;
            const scale = 25;
            const scaledWidth = width * scale;
            const scaledHeight = height * scale;
            const scaledLeft = left - (scaledWidth - width) / 2;
            const scaledTop = top - (scaledHeight - height) / 2;
            this.img.style.transform = `translate(${scaledLeft}px, ${scaledTop}px)`;
            this.img.style.width = `${scaledWidth}px`;
            this.img.style.height = `${scaledHeight}px`;
          }
        }
        // 지도의 시작 위치(center), 확대 레벨(zoom) 등 기본 옵션임.
        // 이유: 초기 화면 어디를 얼마나 확대해 보여줄지 정해야 사용성 좋아짐.
        var mapOptions = {
          center: new naver.maps.LatLng(36.601110505, 127.296293603),
          zoom: 18,
        };
        // 위 옵션으로 실제 지도를 생성해 #map 요소에 렌더함.
        // 이유: JS가 해당 DOM 요소를 찾아 그 안에 지도를 그림. id 필요함.
        map = new naver.maps.Map('map', mapOptions);
        // 지도 위 장치 관리를 담당하는 매니저를 생성합니다.
        mapDeviceManager = new MapDeviceManager(map);
        // 악취 확산 오버레이 생성 후 매니저에 주입
        // const overlay = new OdorHeatmapOverlay(map, DEFAULT_ODOR_RADIUS_M);
        // mapDeviceManager.setOdorOverlay(overlay);
        // 개발자 도구에서 접근할 수 있도록 전역(window)에 노출합니다.
        window.mapDeviceManager = mapDeviceManager;
        // 초기 UI/이벤트/범례를 설정합니다.
        setupMapEvents();
        renderLegend();
        mapDeviceManager.updateMarkerCountInfo();

        // 초기 장치 마커 로드 (devices.json)
        // 초기 장치 위치를 외부 JSON에서 불러옴.
        // 이유: fetch로 정적 파일 데이터 읽어 초기 마커 구성 가능함. 서버 없이도 됨.
        fetch('./devices.json')
          .then(res => res.json())
          .then(list => {
            if (!Array.isArray(list)) return;
            // id 충돌 방지를 위해 시퀀스 보정
            let maxId = 0;
            list.forEach(d => { if (typeof d.id === 'number') maxId = Math.max(maxId, d.id); });
            mapDeviceManager.markerIdSeq = Math.max(mapDeviceManager.markerIdSeq, maxId + 1);
            // 마커 추가
            list.forEach(d => {
              mapDeviceManager.addDeviceMarker({
                id: d.id ?? mapDeviceManager.markerIdSeq++,
                type: d.type,
                name: d.name || `${d.type} ${d.id || ''}`.trim(),
                lat: d.lat,
                lng: d.lng
              });
            });
          })
          .catch(err => console.error('초기 장치 로드 실패:', err));

        // 예시: 이미지 지상 오버레이 인스턴스 생성 (URL/영역은 상황에 맞게 변경)
        // 아래는 예시로 지도 위 특정 영역에 이미지를 덮는 코드입니다.
        const sw = new naver.maps.LatLng(36.600850, 127.296000);
        const ne = new naver.maps.LatLng(36.601350, 127.296550);
        const groundBounds = new naver.maps.LatLngBounds(sw, ne);
        const groundImage = new GroundImageOverlay(
          map,
          './Photos/Odor_conversion_rate_Photo.png',
          groundBounds,
          0.4
        );
        // 필요시 외부에서 제어할 수 있도록 전역 변수로 저장합니다.
        window.groundImage = groundImage;

        // 지도 크기 변경 감지
        // 브라우저 창 크기 변화 등으로 지도가 리사이즈되면 라벨 위치를 재계산합니다.
        map.addListener('resize', () => {
          // 모든 라벨 강제 업데이트
          mapDeviceManager.markers.forEach(marker => {
            if (marker.typeLabel) {
              marker.typeLabel.draw();
            }
          });
        });
      };
    </script>
  </body>
  <!-- HTML 문서의 끝입니다. 여기까지가 브라우저가 해석할 전체입니다. -->
</html>